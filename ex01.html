<!DOCTYPE html>
<html>
    <head>
        <title>Portifolio</title>
        <script>
    async function enviar() {
        const input = document.getElementById("mensagem");
        const texto = input.value;
        input.value = "";

        const chat = document.getElementById("chat");
        chat.innerHTML += `<p><b>Você:</b> ${texto}</p>`;
        chat.scrollTop = chat.scrollHeight;
        try {
            const resposta = await fetch("/mensagem", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ mensagem: texto }),
            });

            const dados = await resposta.json();
            chat.innerHTML += `<p><b>PedroBot:</b> ${dados.resposta}</p>`;
            chat.scrollTop = chat.scrollHeight;
            const utterance = new SpeechSynthesisUtterance(dados.resposta);
            utterance.lang = "pt-BR";
            speechSynthesis.speak(utterance);
        } catch (err) {
            chat.innerHTML += `<p><b>PedroBot:</b> Erro ao responder :(</p>`;
            chat.scrollTop = chat.scrollHeight;
        }
    }
  </script>
        <style>
            body {
                font-family: Arial, sans-serif;
                background-color: white;
                padding: 20px;
                text-align: center;
                color: black;
            }
            .container {
                display: flex;
                flex-direction: column; /* vertical */
                gap: 40px; /* espaço entre os projetos */
                align-items: center; /* centraliza horizontalmente */
            }
            .box {
                background-color: white;
                padding: 20px;
                border-radius: 10px;
                width: 45%;
                min-width: 300px;
                color: black;
            }
            .code pre {
                background-color: black;
                color: white;
                padding: 15px;
                overflow-x: auto;
                font-family: 'Courier New';
                max-height: 600px;
                text-align: left;
            }
            .result img {
                max-width: 100%;
                border-radius: 10px;
                border: 1px solid #ddd;
            }
        </style>
    </head>
    <body>
        <h1>Projetos do Pedro Paulo Pires Caldeira</h1>
        <div class="container">
            <div class="box code">
                <h2>Código de indentificador de cachorro e gato</h2>
                <pre>import cv2 as cv, os, glob, random, shutil, tensorflow as tf, numpy as np
from tensorflow import keras
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Rescaling
from google.colab.patches import cv2_imshow
from tensorflow.keras.utils import image_dataset_from_directory
from tensorflow.keras.callbacks import ModelCheckpoint
from keras.preprocessing import image
cat_img_files=glob.glob('/content/cat/cat.*')
print(len(cat_img_files))
print(cat_img_files)
random_cats=[cv.imread(i) for i in cat_img_files]
cv2_imshow(random_cats[0])
dog_img_files=glob.glob('/content/dog/dog.*')
print(len(dog_img_files))
print(dog_img_files)
random_dogs=[cv.imread(i) for i in dog_img_files]
cv2_imshow(random_dogs[0])
os.mkdir('train_folder')
os.mkdir('train_folder/dog')
os.mkdir('train_folder/cat')
os.mkdir('val_folder')
os.mkdir('val_folder/dog')
os.mkdir('val_folder/cat')
os.mkdir('test_folder')
os.mkdir('test_folder/dog')
os.mkdir('test_folder/cat')
percent_val = 0.10
percent_test = 0.20
new_train_dog='/content/train_folder/dog'
new_train_cat='/content/train_folder/cat'
new_val_dog='/content/val_folder/dog'
new_val_cat='/content/val_folder/cat'
new_test_dog='/content/test_folder/dog'
new_test_cat='/content/test_folder/cat'
def moveImagesToCorrectFolder():
    dog_train_files = glob.glob('/content/dog/dog.*')
    cat_train_files = glob.glob('/content/cat/cat.*')
    for f in dog_train_files:
        rand_val = random.random()
        filename = f.split("/")[-1]
        if rand_val <= percent_val:
            shutil.move(f, new_val_dog + "/" + filename)
        elif rand_val > percent_val and rand_val <= percent_val + percent_test:
            shutil.move(f, new_test_dog + "/" + filename)
        else:
            shutil.move(f, new_train_dog + "/" + filename)
    for f in cat_train_files:
        rand_val = random.random()
        filename = f.split("/")[-1]
        if rand_val <= percent_val:
            shutil.move(f, new_val_cat + "/" + filename)
        elif rand_val > percent_val and rand_val <= percent_val + percent_test:
            shutil.move(f, new_test_cat + "/" + filename)
        else:
            shutil.move(f, new_train_cat + "/" + filename)
moveImagesToCorrectFolder()
print(tf.config.list_physical_devices('GPU'))
train_folder='/content/train_folder'
val_folder='/content/val_folder'
test_folder='/content/test_folder'
train_dataset = image_dataset_from_directory(train_folder,image_size=(180, 180),batch_size=32)
validation_dataset = image_dataset_from_directory(val_folder,image_size=(180, 180),batch_size=32)
test_dataset = image_dataset_from_directory(test_folder,image_size=(180, 180),batch_size=32)
model=keras.Sequential()
model.add(Rescaling(1./255))
model.add(Conv2D(32, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(128, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(256, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(256, kernel_size=(3, 3), activation='relu'))
model.add(Flatten())
model.add(Dense(1, activation="sigmoid"))
model.compile(loss="binary_crossentropy",optimizer="adam",metrics=["accuracy"])
callbacks=[ModelCheckpoint(filepath="model3.keras",save_best_only=True,monitor="val_loss")]
history=model.fit(train_dataset,epochs=30,validation_data=validation_dataset,callbacks=callbacks)
img_ada='ada.jpg'
ada=cv.imread(img_ada)
cv2_imshow(ada)
ada_img=image.load_img('ada.jpg', target_size=(180, 180))
x=image.img_to_array(ada_img)
x=np.expand_dims(x, axis=0)
pred=(model.predict(x) > 0.5).astype('int32')[0][0]
if pred == 1: print("Cachorro")
else: print("Gato")
print(model.predict(x))
img_gato='gato.jpeg'
gato=cv.imread(img_gato)
cv2_imshow(gato)
gato_img=image.load_img('gato.jpeg', target_size=(180, 180))
x1=image.img_to_array(gato_img)
x1=np.expand_dims(x1, axis=0)
pred1=(model.predict(x1) > 0.5).astype('int32')[0][0]
if pred1==1: print('Cachorro')
else: print('Gato')
print(model.predict(x1))</pre>
            </div>
            <div class="box result">
                <h2>Resultados</h2>
                <img src="static\resultado1_projeto_dog_or_cat.png" alt="Primeiro resultado">
                <img src="static\resultado2_projeto_dog_or_cat.png" alt="Segundo resultado">
            </div>
        </div>
        <div class="container">
            <div class="box code">
                <h2>Código de jogo da velha contra computador</h2>
                <pre>def minimax(tabuleiro, profundidade, maximizar_jogador):
  if verifica_vencedor(tabuleiro, 'x'):
    return -1
  elif verifica_vencedor(tabuleiro, 'o'):
    return 1
  elif '_' not in tabuleiro:
    return 0
  if maximizar_jogador:
    max_eval = float('-inf')
    for i in range(9):
      if tabuleiro[i]== '_':
        tabuleiro[i]= 'o'
        eval = minimax(tabuleiro, profundidade + 1, False)
        tabuleiro[i]='_'
        max_eval=max(max_eval, eval)
    return max_eval
  else:
    min_eval = float('inf')
    for i in range(9):
      if tabuleiro[i]=='_':
        tabuleiro[i]= 'x'
        eval = minimax(tabuleiro, profundidade + 1, True)
        tabuleiro[i]='_'
        min_eval=min(min_eval, eval)
    return min_eval
def melhor_jogada(tabuleiro):
  melhor_eval = float('-inf')
  jogada=None
  for i in range(9):
    if tabuleiro[i]=='_':
      tabuleiro[i]='o'
      eval = minimax(tabuleiro, 0, False)
      tabuleiro[i]='_'
      if eval > melhor_eval:
        melhor_eval = eval
        jogada=i
  return jogada
def verifica_vencedor(tabuleiro, jogador):
  if (tabuleiro[0]==jogador and tabuleiro[1]==jogador and tabuleiro[2]==jogador) or (tabuleiro[3]==jogador and tabuleiro[4]==jogador and tabuleiro[5]==jogador) or (tabuleiro[6]==jogador and tabuleiro[7]==jogador and tabuleiro[8]==jogador) or (tabuleiro[0]==jogador and tabuleiro[3]==jogador and tabuleiro[6]==jogador) or (tabuleiro[1]==jogador and tabuleiro[4]==jogador and tabuleiro[7]==jogador) or (tabuleiro[2]==jogador and tabuleiro[5]==jogador and tabuleiro[8]==jogador) or (tabuleiro[0]==jogador and tabuleiro[4]==jogador and tabuleiro[8]==jogador) or (tabuleiro[2]==jogador and tabuleiro[4]==jogador and tabuleiro[6]==jogador):
    return True
def tabuleiro_cheio(tabuleiro):
  return not any('_' in linha for linha in tabuleiro)
def exibir(tabuleiro):
  print(' '.join(tabuleiro[0:3]))
  print(' '.join(tabuleiro[3:6]))
  print(' '.join(tabuleiro[6:9]))
def jogar():
  L=['_']*9
  exibir(L)
  while True:
    a=int(input('Digite o sua jogada:'))
    if L[a-1]=='_':
      L[a-1]='x'
    if verifica_vencedor(L, 'x'):
      exibir(L)
      print('Parabéns o humano ganhou!')
      break
    if tabuleiro_cheio(L):
      exibir(L)
      print('Empatou!')
      break
    b=melhor_jogada(L)
    L[b]='o'
    exibir(L)
    if verifica_vencedor(L, 'o'):
      exibir(L)
      print('Parabéns o computador ganhou!')
      break
jogar()</pre>
            </div>
            <div class="box result">
                <h2>Resultados</h2>
                <img src="static\resultado_jogo_da_velha_cotra_computador.png" alt="Resultado">
            </div>
        </div>
        <div class="container">
            <div class="box code">
                <h2>Código de ação da Petrobras</h2>
                <pre>from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM
import pandas as pd, numpy as np, tensorflow as tf, matplotlib.pyplot as plt

dados=pd.read_csv('/content/PETR4.SA2.csv')
dados.head()
precos=dados['Close']
precos
days_time_step=15
training_size=int(len(precos)*0.95)
test_size=len(precos) - training_size
train_data, input_data=np.array(precos[0:training_size]), np.array(precos[training_size-days_time_step:])
test_data=np.array(precos[training_size:])
print(train_data.shape, input_data.shape, test_data.shape)
scaler=MinMaxScaler(feature_range=(0,1))
train_data_norm=scaler.fit_transform(np.array(train_data).reshape(-1,1))
test_data_norm=scaler.transform(np.array(input_data).reshape(-1,1))
val_data_norm=scaler.transform(np.array(test_data).reshape(-1,1))
print(train_data_norm.shape, test_data_norm.shape, val_data_norm.shape)
X_train, y_train, X_test, X_val, y_val= [], [], [], [], []
for i in range(days_time_step, len(train_data)):
    X_train.append(train_data_norm[i-days_time_step:i])
    y_train.append(train_data_norm[i])

for i in range(days_time_step, days_time_step + len(test_data)):
    X_test.append(test_data_norm[i-days_time_step:i])

for i in range(days_time_step, len(test_data)):
    X_val.append(val_data_norm[i-days_time_step:i])
    y_val.append(val_data_norm[i])

X_train = np.array(X_train)
y_train = np.array(y_train)
X_test = np.array(X_test)
X_val = np.array(X_val)
y_val = np.array(y_val)

X_test.shape

model=Sequential()
model.add(LSTM(units=100, activation='tanh', input_shape=(days_time_step, 1)))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_val, y_val))

predict=model.predict(X_test)
predict=scaler.inverse_transform(predict)
real=test_data
predict.shape

plt.figure(figsize = (14,19))
plt.plot(real, color = 'green', label = 'real')
plt.plot(predict, color = 'red', label = 'previsão')
plt.xticks(range(0, len(real), 50), dados['Date'].iloc[- len(real)::50], rotation=45)
plt.xlabel('Datas', fontsize=18)
plt.ylabel('Preço Médio', fontsize=18)
plt.title("Projeção de Preço PETR4", fontsize=30)
plt.legend()
plt.show()</pre>
            </div>
            <div class="box result">
                <h2>Resultados</h2>
                <img src="static\reposta_açao_petrobras.png" alt="Resultado">
            </div>
        </div>
        <div class="container">
            <div class="box code">
                <h2>Código de detecção de sono</h2>
                <pre>import cv2, mediapipe as mp, numpy as np, time
p_boca,p_olho_esq,p_olho_dir= [82, 87, 13, 14, 312, 317, 78, 308], [385, 380, 387, 373, 362, 263],[160, 144, 158, 153, 33, 133]
p_olho=p_olho_esq+p_olho_dir
def calculo_ear(face, p_olho_dir,p_olho_esq):
    try:
        face=np.array([[coord.x, coord.y] for coord in face])
        face_esq=face[p_olho_esq,:]
        face_dir=face[p_olho_dir, :]
            
        ear_esq=(np.linalg.norm(face_esq[0]-face_esq[1])+np.linalg.norm(face_esq[2]-face_esq[3]))/(2*(np.linalg.norm(face_esq[4]-face_esq[5])))
        ear_dir=(np.linalg.norm(face_dir[0]-face_dir[1])+np.linalg.norm(face_dir[2]-face_dir[3]))/(2*(np.linalg.norm(face_dir[4]-face_dir[5])))
    except:
        ear_esq,ear_dir=0.0, 0.0
    return (ear_esq+ear_dir)/2
def calculo_mar(face, p_boca):
    try:
        face=np.array([[coord.x, coord.y] for coord in face])
        face_boca = face[p_boca,:]
        mar = (np.linalg.norm(face_boca[0]-face_boca[1])+np.linalg.norm(face_boca[2]-face_boca[3])+np.linalg.norm(face_boca[4]-face_boca[5]))/(2*(np.linalg.norm(face_boca[6]-face_boca[7])))
    except:
        mar=0.0
    return mar
mp_drawing,mp_face_mesh,ear_limiar,mar_limiar,dormindo,contagem_piscadas=mp.solutions.drawing_utils,mp.solutions.face_mesh,0.3,0.1,0,0
cap=cv2.VideoCapture(0)
with mp_face_mesh.FaceMesh(min_detection_confidence=0.5, min_tracking_confidence=0.5) as facemesh:
    while cap.isOpened():
        sucesso, frame=cap.read()
        if not sucesso:
            print('Ignorando o frame vazio da camera.')
            continue
        comprimento,largura,_=frame.shape
        frame=cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        saida_facemesh=facemesh.process(frame)
        frame=cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        try:
            for face_landmarks in saida_facemesh.multi_face_landmarks:
                mp_drawing.draw_landmarks(frame, face_landmarks, mp_face_mesh.FACEMESH_CONTOURS,
                landmark_drawing_spec = mp_drawing.DrawingSpec(color=(255,102,102), thickness=1, circle_radius=1),
                connection_drawing_spec = mp_drawing.DrawingSpec(color=(102,204,0), thickness=1, circle_radius=1))
                face=face_landmarks.landmark
                for id_coord, coord_xyz in enumerate(face):
                    if id_coord in p_olho:
                        coord_cv = mp_drawing._normalized_to_pixel_coordinates(coord_xyz.x,coord_xyz.y, largura, comprimento)
                        cv2.circle(frame, coord_cv, 2, (255,0,0), -1)
                    if id_coord in p_boca:
                        coord_cv = mp_drawing._normalized_to_pixel_coordinates(coord_xyz.x,coord_xyz.y, largura, comprimento)
                        cv2.circle(frame, coord_cv, 2, (255,0,0), -1)
                ear = calculo_ear(face,p_olho_dir, p_olho_esq)
                cv2.rectangle(frame, (0,1),(290,140),(58,58,55),-1)
                cv2.putText(frame, f"EAR: {round(ear, 2)}", (1, 24),cv2.FONT_HERSHEY_DUPLEX,0.9, (255, 255, 255), 2)
                mar = calculo_mar(face,p_boca)
                cv2.putText(frame, f"MAR: {round(mar, 2)} {'Aberto' if mar >= mar_limiar else 'Fechado'}", (1, 50), cv2.FONT_HERSHEY_DUPLEX, 0.9, (255, 255, 255), 2)
                if ear < ear_limiar or mar<mar_limiar:
                    t_inicial=time.time() if dormindo==0 else t_inicial
                    contagem_piscadas = contagem_piscadas+1 if dormindo == 0 else contagem_piscadas
                    dormindo=1
                if (dormindo==1 and ear >= ear_limiar) or (ear <= ear_limiar and mar >= mar_limiar):
                    dormindo=0
                t_final=time.time()
                cv2.putText(frame, f"Piscadas: {contagem_piscadas}", (1, 120),cv2.FONT_HERSHEY_DUPLEX,0.9, (109, 233, 219), 2)
                tempo=(t_final-t_inicial) if dormindo==1 else 0.0
                cv2.putText(tempo, f"Tempo: {round(tempo, 2)}", (1, 24),cv2.FONT_HERSHEY_DUPLEX,0.9, (255, 255, 255), 2)
                if tempo>=1.5:
                    cv2.rectangle(frame, (30, 400),(610, 452),(109, 233, 219),-1)
                    cv2.putText(frame, f"Muito tempo com olhos fechados!", (80, 435),cv2.FONT_HERSHEY_DUPLEX,0.85, (58, 58, 55), 1)
        except:
            pass
        cv2.imshow('Camera', frame)
        if cv2.waitKey(10) & 0xFF == ord('c'):
            break
cap.release()
cv2.destroyAllWindows()</pre>
            </div>
            <div class="box result">
                <h2>Resultados</h2>
                <img src="static\resultado_projeto_detecçao_de_sono.png" alt="Resultado">
            </div>
            <div class="container">
                <div class="box result" id="pedrobot-box">
                    <h3>PedroBot</h3>
                    <div id="chat" style="border:1px solid #ccc; padding:20px; height: 400px; font-size: 16px; overflow-y:auto;"></div>
                    <input type="text" id="mensagem" placeholder="Digite aqui..." />
                    <button onclick="enviar()">Enviar</button>
                </div>
            </div>
        </div>
    </body>
</html>